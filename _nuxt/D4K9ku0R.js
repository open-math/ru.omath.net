import{aI as j,aJ as A,aK as V,aL as H,aM as D,aN as W,f as m,c as l,o as a,F as P,r as U,l as d,n as R,_ as w,w as h,E as G,aO as q,m as b,aP as L,b as k,q as S,g as t,Z as z,U as I,B as M,a as E,t as T,aQ as J,aR as K,aS as O,aB as Q,aT as Z,aD as X,aU as Y,aV as ee}from"./CArnVfK8.js";import{a as ne,c as re,d as oe,e as te,f as ae}from"./D_Ce_GXt.js";function v(n){const e=n.name,o={...ne(),[H]:A,[V]:j}[e];if(!o)throw new Error(`Failed to find renderer for element "${e}"!`);return o}async function se(n){var s;const r=(s=re().preRenderData)==null?void 0:s[n.autoId];if(r){if(r.type==="error")throw new Error(r.message);return r.data}const c=v(n).createRenderData;return c?c(n):void 0}async function F(n){if(n instanceof D||n instanceof W)return{error:n.error};const e=v(n);try{return n.renderData=await se(n),{ElementComponent:await e.component()}}catch(r){return{error:r instanceof Error?r:new Error(String(r))}}}const ce=m({__name:"RenderGroup",props:{node:{}},setup(n){return(e,r)=>(a(!0),l(P,null,U(e.node.children??[],o=>(a(),d(De,{node:o},null,8,["node"]))),256))}}),N=m({__name:"BlockFloat",props:{position:{}},setup(n){return(e,r)=>(a(),l("div",{class:R({"bitran-blockFloat":!0,[`bitran-blockFloat--${e.position}`]:!0})},null,2))}}),ie={};function de(n,e){return a(),d(q,{name:"bitran-transition--fade"},{default:h(()=>[G(n.$slots,"default")]),_:3})}const le=w(ie,[["render",de]]),ue={class:"bitran-blockAside"},_e=["innerHTML"],pe=m({__name:"BlockAside",props:{node:{},hovered:{type:Boolean},error:{}},async setup(n){let e,r;const c=v(n.node),s=([e,r]=b(()=>L(c)),e=await e,r(),e);return(i,_)=>(a(),l("div",ue,[k(le,null,{default:h(()=>[i.hovered||i.error?(a(),l("div",{key:0,class:"bitran-blockAsideIcon",innerHTML:t(s)},null,8,_e)):S("",!0)]),_:1})]))}}),me=["id"],fe={key:1,class:"bitran-block"},ve={class:"bitran-blockMain"},he={key:0},ke=m({__name:"Block",props:{node:{}},async setup(n){let e,r;const o=n,c=v(o.node),s=z("block"),i=I(!1),_=(()=>{if(!(o.node instanceof D))return""+o.node.id})(),{ElementComponent:p,error:u}=([e,r]=b(()=>F(o.node)),e=await e,r(),e);return M(()=>{s.value.addEventListener("mouseenter",()=>{i.value=!0}),s.value.addEventListener("mouseleave",()=>{i.value=!1})}),(f,y)=>(a(),l("div",{ref:"block",id:t(_),class:R({"bitran-blockContainer":!0,"bitran-blockContainer--hover":i.value,"bitran-error":t(u)})},[k(N,{position:"above"}),t(c).customLayout&&!t(u)?(a(),d(t(p),{key:0,node:f.node},null,8,["node"])):(a(),l("div",fe,[k(pe,{node:f.node,hovered:i.value,error:t(u)},null,8,["node","hovered","error"]),E("div",ve,[t(u)?(a(),l("div",he,T(t(u)),1)):(a(),d(t(p),{key:1,node:f.node},null,8,["node"]))])])),k(N,{position:"below"})],10,me))}}),be={};function ye(n,e){return a(),l("div",null,"Block loading...")}const Ee=w(be,[["render",ye]]),Re={key:0,class:R({"bitran-inliner":!0,"bitran-error":!0})},we=["innerHTML"],$e=m({__name:"Inliner",props:{node:{}},async setup(n){let e,r;const o=n,{ElementComponent:c,error:s}=([e,r]=b(()=>F(o.node)),e=await e,r(),e),i=v(o.node),_=([e,r]=b(()=>L(i)),e=await e,r(),e);return(p,u)=>t(s)?(a(),l("span",Re,[E("span",{class:"bitran-inlinerErrorIcon",innerHTML:t(_)},null,8,we),E("span",null,T(t(s)),1)])):(a(),d(t(c),{key:1,node:p.node},null,8,["node"]))}}),ge={};function Be(n,e){return a(),l("span",null,"Inliner loading...")}const Ce=w(ge,[["render",Be]]),Ne=m({__name:"RenderElement",props:{node:{}},async setup(n){let e,r;const o=n,c=o.node instanceof J,s=oe(),i=te(),_=ae(),p=v(o.node),u=_.value?"client":o.node instanceof K||o.node instanceof O||p.ssr?"hybrid":"client",f=C=>Q(C,{node:o.node}),y=f(c?ke:$e),x=f(c?Ee:Ce);let $=!0;const g=p.canRender;!_.value&&g&&($=([e,r]=b(()=>g({isDev:s.isDev,isProd:s.isDev===void 0?void 0:!s.isDev,isServer:s.isServer,isClient:s.isServer===void 0?void 0:!s.isServer,node:o.node})),e=await e,r(),e));const B=I(!1);return M(()=>setTimeout(()=>B.value=!0,500)),(C,Le)=>t($)?(a(),d(t(i),{key:0,mode:t(u)},{default:h(()=>[t(u)==="hybrid"?(a(),d(t(y),{key:0})):(a(),d(Z,{key:1},{fallback:h(()=>[B.value?(a(),d(t(x),{key:0})):(a(),d(X(c?"div":"span"),{key:1}))]),default:h(()=>[k(t(y))]),_:1}))]),_:1},8,["mode"])):S("",!0)}}),De=m({__name:"Render",props:{node:{}},setup(n){const e=n,r=(()=>{switch(!0){case e.node instanceof ee:return ce;case e.node instanceof Y:return Ne;default:throw new Error(`Unsupported node "${e.node.constructor.name}"!`)}})();return(o,c)=>(a(),d(t(r),{node:o.node},null,8,["node"]))}});export{De as _};
